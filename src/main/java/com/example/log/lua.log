local function acquire(key, permits, curr_mill_second) local rate_limit_info = redis.pcall('HMGET', key, 'last_mill_second', 'curr_permits', 'max_permits', 'period'); local last_mill_second = rate_limit_info[1]; local curr_permits = tonumber(rate_limit_info[2]); local max_permits = tonumber(rate_limit_info[3]); local period = rate_limit_info[4];  if (max_permits == nil) then return 1; end local local_curr_permits = max_permits;  if (type(last_mill_second) ~= 'boolean' and last_mill_second ~= nil) then local reverse_permits = math.floor((curr_mill_second - last_mill_second) / (period * 1000)) * max_permits; local expect_curr_permits = reverse_permits + curr_permits; local_curr_permits = math.min(expect_curr_permits, max_permits); last_mill_second if (reverse_permits > 0) then redis.pcall('HSET', key, 'last_mill_second', curr_mill_second); end else redis.pcall('HSET', key, 'last_mill_second', curr_mill_second); end local result = {}; if (local_curr_permits - permits >= 0) then result.permit = local_curr_permits - permits; result.cert_id = redis.pcall('HGET', key, 'cert_id'); redis.pcall('HSET', key, 'curr_permits', local_curr_permits - permits); else  redis.pcall('HSET', key, 'curr_permits', 0); end return result; end return acquire('asd:asd','1','1615192828000')